{"version":3,"sources":["../src/index.ts","../src/endpoint.ts","../src/error.ts","../src/helper.ts","../src/cookie.ts","../src/cookie-utils.ts","../src/router.ts","../src/utils.ts","../src/middleware.ts","../src/types.ts","../src/adapter/node.ts","../src/adapter/request.ts"],"sourcesContent":["export * from \"./endpoint\";\nexport * from \"./router\";\nexport * from \"./middleware\";\nexport * from \"./error\";\nexport * from \"./utils\";\nexport * from \"./types\";\nexport * from \"./adapter\";\nexport * from \"./cookie\";\nexport * from \"./cookie-utils\";\n","\"use server\";\nimport { ZodError } from \"zod\";\nimport { APIError } from \"./error\";\nimport { json, type HasRequiredKeys } from \"./helper\";\nimport type {\n\tContext,\n\tContextTools,\n\tEndpoint,\n\tEndpointOptions,\n\tEndpointResponse,\n\tHandler,\n\tInferUse,\n\tPrettify,\n} from \"./types\";\nimport { getCookie, getSignedCookie, setCookie, setSignedCookie } from \"./cookie-utils\";\nimport type { CookiePrefixOptions, CookieOptions } from \"./cookie\";\n\nexport interface EndpointConfig {\n\t/**\n\t * Throw when the response isn't in 200 range\n\t */\n\tthrowOnError?: boolean;\n}\n\nexport function createEndpointCreator<\n\tE extends {\n\t\tuse?: Endpoint[];\n\t},\n>(opts?: E) {\n\treturn <Path extends string, Opts extends EndpointOptions, R extends EndpointResponse>(\n\t\tpath: Path,\n\t\toptions: Opts,\n\t\thandler: (\n\t\t\tctx: Prettify<\n\t\t\t\tContext<Path, Opts> &\n\t\t\t\t\tInferUse<Opts[\"use\"]> &\n\t\t\t\t\tInferUse<E[\"use\"]> &\n\t\t\t\t\tOmit<ContextTools, \"_flag\">\n\t\t\t>,\n\t\t) => Promise<R>,\n\t) => {\n\t\treturn createEndpoint(\n\t\t\tpath,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tuse: [...(options?.use || []), ...(opts?.use || [])],\n\t\t\t},\n\t\t\thandler,\n\t\t);\n\t};\n}\n\nexport function createEndpoint<\n\tPath extends string,\n\tOpts extends EndpointOptions,\n\tR extends EndpointResponse,\n>(path: Path, options: Opts, handler: Handler<Path, Opts, R>) {\n\tconst responseHeader = new Headers();\n\ttype Ctx = Context<Path, Opts>;\n\tconst handle = async (...ctx: HasRequiredKeys<Ctx> extends true ? [Ctx] : [Ctx?]) => {\n\t\tlet internalCtx = {\n\t\t\tsetHeader(key: string, value: string) {\n\t\t\t\tresponseHeader.set(key, value);\n\t\t\t},\n\t\t\tsetCookie(key: string, value: string, options?: CookieOptions) {\n\t\t\t\tsetCookie(responseHeader, key, value, options);\n\t\t\t},\n\t\t\tgetCookie(key: string, prefix?: CookiePrefixOptions) {\n\t\t\t\tconst header = ctx[0]?.headers;\n\t\t\t\tconst cookieH = header?.get(\"cookie\");\n\t\t\t\tconst cookie = getCookie(cookieH || \"\", key, prefix);\n\t\t\t\treturn cookie;\n\t\t\t},\n\t\t\tgetSignedCookie(key: string, secret: string, prefix?: CookiePrefixOptions) {\n\t\t\t\tconst header = ctx[0]?.headers;\n\t\t\t\tif (!header) {\n\t\t\t\t\tthrow new TypeError(\"Headers are required\");\n\t\t\t\t}\n\t\t\t\tconst cookie = getSignedCookie(header, secret, key, prefix);\n\t\t\t\treturn cookie;\n\t\t\t},\n\t\t\tasync setSignedCookie(\n\t\t\t\tkey: string,\n\t\t\t\tvalue: string,\n\t\t\t\tsecret: string | BufferSource,\n\t\t\t\toptions?: CookieOptions,\n\t\t\t) {\n\t\t\t\tawait setSignedCookie(responseHeader, key, value, secret, options);\n\t\t\t},\n\t\t\tredirect(url: string) {\n\t\t\t\tresponseHeader.set(\"Location\", url);\n\t\t\t\treturn new APIError(\"FOUND\");\n\t\t\t},\n\t\t\tjson,\n\t\t\tcontext: (ctx[0] as any)?.context || {},\n\t\t\t_flag: (ctx[0] as any)?._flag as string,\n\t\t\tresponseHeader,\n\t\t\tpath: path,\n\t\t\t...(ctx[0] || {}),\n\t\t};\n\t\tif (options.use?.length) {\n\t\t\tlet middlewareContexts = {};\n\t\t\tlet middlewareBody = {};\n\t\t\tfor (const middleware of options.use) {\n\t\t\t\tif (typeof middleware !== \"function\") {\n\t\t\t\t\tconsole.warn(\"Middleware is not a function\", {\n\t\t\t\t\t\tmiddleware,\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst res = (await middleware(internalCtx)) as Endpoint;\n\t\t\t\tif (res) {\n\t\t\t\t\tconst body = res.options?.body\n\t\t\t\t\t\t? res.options.body.parse(internalCtx.body)\n\t\t\t\t\t\t: undefined;\n\t\t\t\t\tmiddlewareContexts = {\n\t\t\t\t\t\t...middlewareContexts,\n\t\t\t\t\t\t...res,\n\t\t\t\t\t};\n\t\t\t\t\tmiddlewareBody = {\n\t\t\t\t\t\t...middlewareBody,\n\t\t\t\t\t\t...body,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tinternalCtx = {\n\t\t\t\t...internalCtx,\n\t\t\t\tbody: {\n\t\t\t\t\t...middlewareBody,\n\t\t\t\t\t...internalCtx.body,\n\t\t\t\t},\n\t\t\t\tcontext: {\n\t\t\t\t\t...(internalCtx.context || {}),\n\t\t\t\t\t...middlewareContexts,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tconst body = options.body ? options.body.parse(internalCtx.body) : internalCtx.body;\n\t\t\tinternalCtx = {\n\t\t\t\t...internalCtx,\n\t\t\t\tbody: body\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...body,\n\t\t\t\t\t\t\t...internalCtx.body,\n\t\t\t\t\t\t}\n\t\t\t\t\t: internalCtx.body,\n\t\t\t};\n\t\t\tinternalCtx.query = options.query\n\t\t\t\t? options.query.parse(internalCtx.query)\n\t\t\t\t: internalCtx.query;\n\t\t} catch (e) {\n\t\t\tif (e instanceof ZodError) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: e.message,\n\t\t\t\t\tdetails: e.errors,\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t\tif (options.requireHeaders && !internalCtx.headers) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Headers are required\",\n\t\t\t});\n\t\t}\n\t\tif (options.requireRequest && !internalCtx.request) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Request is required\",\n\t\t\t});\n\t\t}\n\t\t//@ts-expect-error\n\t\tlet res = (await handler(internalCtx)) as any;\n\n\t\tlet actualResponse: any = res;\n\n\t\tif (res && typeof res === \"object\" && \"_flag\" in res) {\n\t\t\tif (res._flag === \"json\" && internalCtx._flag === \"router\") {\n\t\t\t\tconst h = res.response.headers as Record<string, string>;\n\t\t\t\tObject.keys(h || {}).forEach((key) => {\n\t\t\t\t\tresponseHeader.set(key, h[key as keyof typeof h]);\n\t\t\t\t});\n\t\t\t\tactualResponse = new Response(JSON.stringify(res.response.body), {\n\t\t\t\t\tstatus: res.response.status ?? 200,\n\t\t\t\t\tstatusText: res.response.statusText,\n\t\t\t\t\theaders: responseHeader,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tactualResponse = res.body;\n\t\t\t}\n\t\t}\n\n\t\ttype ReturnT = Awaited<ReturnType<Handler<Path, Opts, R>>>;\n\t\treturn actualResponse as R extends {\n\t\t\t_flag: \"json\";\n\t\t}\n\t\t\t? R extends { body: infer B }\n\t\t\t\t? B\n\t\t\t\t: null\n\t\t\t: Awaited<ReturnT>;\n\t};\n\thandle.path = path;\n\thandle.options = options;\n\thandle.method = options.method;\n\thandle.headers = responseHeader;\n\treturn handle;\n}\n","import type { statusCode } from \"./utils\";\n\ntype Status = keyof typeof statusCode;\n\nexport class APIError extends Error {\n\tstatus: Status;\n\tbody: Record<string, any>;\n\tconstructor(status: Status, body?: Record<string, any>) {\n\t\tsuper(`API Error: ${status} ${body?.message ?? \"\"}`, {\n\t\t\tcause: body,\n\t\t});\n\t\tthis.status = status;\n\t\tthis.body = body ?? {};\n\t\tthis.stack = \"\";\n\t\tthis.name = \"BetterCallAPIError\";\n\t}\n}\n","export type UnionToIntersection<Union> = (\n\tUnion extends unknown\n\t\t? (distributedUnion: Union) => void\n\t\t: never\n) extends (mergedIntersection: infer Intersection) => void\n\t? Intersection & Union\n\t: never;\n\nexport type RequiredKeysOf<BaseType extends object> = Exclude<\n\t{\n\t\t[Key in keyof BaseType]: BaseType extends Record<Key, BaseType[Key]> ? Key : never;\n\t}[keyof BaseType],\n\tundefined\n>;\n\nexport type HasRequiredKeys<BaseType extends object> = RequiredKeysOf<BaseType> extends never\n\t? false\n\t: true;\n\n/**\n * this function will return a json response and\n * infers the type of the body\n */\nexport const json = <T>(\n\tbody: T,\n\toption?: {\n\t\tstatus?: number;\n\t\tstatusText?: string;\n\t\theaders?: Record<string, string>;\n\t\t/**\n\t\t * this body will take precedence over the body in the options if both are provided.\n\t\t * This is useful if you want to return body without inferring the type.\n\t\t */\n\t\tbody?: any;\n\t},\n) => {\n\treturn {\n\t\tresponse: {\n\t\t\tbody: option?.body ?? body,\n\t\t\tstatus: option?.status ?? 200,\n\t\t\tstatusText: option?.statusText ?? \"OK\",\n\t\t\theaders: option?.headers,\n\t\t},\n\t\tbody,\n\t\t_flag: \"json\" as const,\n\t};\n};\n","//https://github.com/honojs/hono/blob/main/src/utils/cookie.ts\n\nexport type Cookie = Record<string, string>;\nexport type SignedCookie = Record<string, string | false>;\n\ntype PartitionCookieConstraint =\n\t| { partition: true; secure: true }\n\t| { partition?: boolean; secure?: boolean }; // reset to default\ntype SecureCookieConstraint = { secure: true };\ntype HostCookieConstraint = { secure: true; path: \"/\"; domain?: undefined };\n\nexport type CookieOptions = {\n\tdomain?: string;\n\texpires?: Date;\n\thttpOnly?: boolean;\n\tmaxAge?: number;\n\tpath?: string;\n\tsecure?: boolean;\n\tsigningSecret?: string;\n\tsameSite?: \"Strict\" | \"Lax\" | \"None\" | \"strict\" | \"lax\" | \"none\";\n\tpartitioned?: boolean;\n\tprefix?: CookiePrefixOptions;\n} & PartitionCookieConstraint;\nexport type CookiePrefixOptions = \"host\" | \"secure\";\n\nexport type CookieConstraint<Name> = Name extends `__Secure-${string}`\n\t? CookieOptions & SecureCookieConstraint\n\t: Name extends `__Host-${string}`\n\t\t? CookieOptions & HostCookieConstraint\n\t\t: CookieOptions;\n\nconst algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\n\nconst getCryptoKey = async (secret: string | BufferSource): Promise<CryptoKey> => {\n\tconst secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n\treturn await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\n\nconst makeSignature = async (value: string, secret: string | BufferSource): Promise<string> => {\n\tconst key = await getCryptoKey(secret);\n\tconst signature = await crypto.subtle.sign(\n\t\talgorithm.name,\n\t\tkey,\n\t\tnew TextEncoder().encode(value),\n\t);\n\t// the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs\n\treturn btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\n\nconst verifySignature = async (\n\tbase64Signature: string,\n\tvalue: string,\n\tsecret: CryptoKey,\n): Promise<boolean> => {\n\ttry {\n\t\tconst signatureBinStr = atob(base64Signature);\n\t\tconst signature = new Uint8Array(signatureBinStr.length);\n\t\tfor (let i = 0, len = signatureBinStr.length; i < len; i++) {\n\t\t\tsignature[i] = signatureBinStr.charCodeAt(i);\n\t\t}\n\t\treturn await crypto.subtle.verify(\n\t\t\talgorithm,\n\t\t\tsecret,\n\t\t\tsignature,\n\t\t\tnew TextEncoder().encode(value),\n\t\t);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n// all alphanumeric chars and all of _!#$%&'*.^`|~+-\n// (see: https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1)\nconst validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\n\n// all ASCII chars 32-126 except 34, 59, and 92 (i.e. space to tilde but not double quote, semicolon, or backslash)\n// (see: https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1)\n//\n// note: the spec also prohibits comma and space, but we allow both since they are very common in the real world\n// (see: https://github.com/golang/go/issues/7243)\nconst validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\n\nexport const parse = (cookie: string, name?: string): Cookie => {\n\tconst pairs = cookie.trim().split(\";\");\n\treturn pairs.reduce((parsedCookie, pairStr) => {\n\t\tpairStr = pairStr.trim();\n\t\tconst valueStartPos = pairStr.indexOf(\"=\");\n\t\tif (valueStartPos === -1) {\n\t\t\treturn parsedCookie;\n\t\t}\n\n\t\tconst cookieName = pairStr.substring(0, valueStartPos).trim();\n\t\tif ((name && name !== cookieName) || !validCookieNameRegEx.test(cookieName)) {\n\t\t\treturn parsedCookie;\n\t\t}\n\n\t\tlet cookieValue = pairStr.substring(valueStartPos + 1).trim();\n\t\tif (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n\t\t\tcookieValue = cookieValue.slice(1, -1);\n\t\t}\n\t\tif (validCookieValueRegEx.test(cookieValue)) {\n\t\t\tparsedCookie[cookieName] = decodeURIComponent(cookieValue);\n\t\t}\n\n\t\treturn parsedCookie;\n\t}, {} as Cookie);\n};\n\nexport const parseSigned = async (\n\tcookie: string,\n\tsecret: string | BufferSource,\n\tname?: string,\n): Promise<SignedCookie> => {\n\tconst parsedCookie: SignedCookie = {};\n\tconst secretKey = await getCryptoKey(secret);\n\n\tfor (const [key, value] of Object.entries(parse(cookie, name))) {\n\t\tconst signatureStartPos = value.lastIndexOf(\".\");\n\t\tif (signatureStartPos < 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst signedValue = value.substring(0, signatureStartPos);\n\t\tconst signature = value.substring(signatureStartPos + 1);\n\t\tif (signature.length !== 44 || !signature.endsWith(\"=\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst isVerified = await verifySignature(signature, signedValue, secretKey);\n\t\tparsedCookie[key] = isVerified ? signedValue : false;\n\t}\n\n\treturn parsedCookie;\n};\n\nconst _serialize = (name: string, value: string, opt: CookieOptions = {}): string => {\n\tlet cookie = `${name}=${value}`;\n\n\tif (name.startsWith(\"__Secure-\") && !opt.secure) {\n\t\topt.secure = true;\n\t}\n\n\tif (name.startsWith(\"__Host-\")) {\n\t\t// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.3.2\n\t\tif (!opt.secure) {\n\t\t\topt.secure = true;\n\t\t}\n\n\t\tif (opt.path !== \"/\") {\n\t\t\topt.path = \"/\";\n\t\t}\n\n\t\tif (opt.domain) {\n\t\t\topt.domain = undefined;\n\t\t}\n\t}\n\n\tif (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n\t\tif (opt.maxAge > 34560000) {\n\t\t\t// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.2.2\n\t\t\tthrow new Error(\n\t\t\t\t\"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\",\n\t\t\t);\n\t\t}\n\t\tcookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n\t}\n\n\tif (opt.domain && opt.prefix !== \"host\") {\n\t\tcookie += `; Domain=${opt.domain}`;\n\t}\n\n\tif (opt.path) {\n\t\tcookie += `; Path=${opt.path}`;\n\t}\n\n\tif (opt.expires) {\n\t\tif (opt.expires.getTime() - Date.now() > 34560000_000) {\n\t\t\t// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.2.1\n\t\t\tthrow new Error(\n\t\t\t\t\"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\",\n\t\t\t);\n\t\t}\n\t\tcookie += `; Expires=${opt.expires.toUTCString()}`;\n\t}\n\n\tif (opt.httpOnly) {\n\t\tcookie += \"; HttpOnly\";\n\t}\n\n\tif (opt.secure) {\n\t\tcookie += \"; Secure\";\n\t}\n\n\tif (opt.sameSite) {\n\t\tcookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n\t}\n\n\tif (opt.partitioned) {\n\t\t// FIXME: replace link to RFC\n\t\t// https://www.ietf.org/archive/id/draft-cutler-httpbis-partitioned-cookies-01.html#section-2.3\n\t\tif (!opt.secure) {\n\t\t\tthrow new Error(\"Partitioned Cookie must have Secure attributes\");\n\t\t}\n\t\tcookie += \"; Partitioned\";\n\t}\n\n\treturn cookie;\n};\n\nexport const serialize = <Name extends string>(\n\tname: Name,\n\tvalue: string,\n\topt?: CookieConstraint<Name>,\n): string => {\n\tvalue = encodeURIComponent(value);\n\treturn _serialize(name, value, opt);\n};\n\nexport const serializeSigned = async (\n\tname: string,\n\tvalue: string,\n\tsecret: string | BufferSource,\n\topt: CookieOptions = {},\n): Promise<string> => {\n\tconst signature = await makeSignature(value, secret);\n\tvalue = `${value}.${signature}`;\n\tvalue = encodeURIComponent(value);\n\treturn _serialize(name, value, opt);\n};\n","//https://github.com/honojs/hono/blob/main/src/helper/cookie/index.ts\n\nimport {\n\tparse,\n\tparseSigned,\n\tserialize,\n\tserializeSigned,\n\ttype CookieOptions,\n\ttype CookiePrefixOptions,\n} from \"./cookie\";\n\nexport const getCookie = (cookie: string, key: string, prefix?: CookiePrefixOptions) => {\n\tif (!cookie) {\n\t\treturn undefined;\n\t}\n\tlet finalKey = key;\n\tif (prefix) {\n\t\tif (prefix === \"secure\") {\n\t\t\tfinalKey = \"__Secure-\" + key;\n\t\t} else if (prefix === \"host\") {\n\t\t\tfinalKey = \"__Host-\" + key;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tconst obj = parse(cookie, finalKey);\n\treturn obj[finalKey];\n};\n\nexport const setCookie = (\n\theader: Headers,\n\tname: string,\n\tvalue: string,\n\topt?: CookieOptions,\n): void => {\n\t// Cookie names prefixed with __Secure- can be used only if they are set with the secure attribute.\n\t// Cookie names prefixed with __Host- can be used only if they are set with the secure attribute, must have a path of / (meaning any path at the host)\n\t// and must not have a Domain attribute.\n\t// Read more at https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes'\n\tlet cookie;\n\tif (opt?.prefix === \"secure\") {\n\t\tcookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n\t} else if (opt?.prefix === \"host\") {\n\t\tcookie = serialize(\"__Host-\" + name, value, {\n\t\t\t...opt,\n\t\t\tpath: \"/\",\n\t\t\tsecure: true,\n\t\t\tdomain: undefined,\n\t\t});\n\t} else {\n\t\tcookie = serialize(name, value, { path: \"/\", ...opt });\n\t}\n\theader.append(\"Set-Cookie\", cookie);\n};\n\nexport const setSignedCookie = async (\n\theader: Headers,\n\tname: string,\n\tvalue: string,\n\tsecret: string | BufferSource,\n\topt?: CookieOptions,\n): Promise<void> => {\n\tlet cookie;\n\tif (opt?.prefix === \"secure\") {\n\t\tcookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n\t\t\tpath: \"/\",\n\t\t\t...opt,\n\t\t\tsecure: true,\n\t\t});\n\t} else if (opt?.prefix === \"host\") {\n\t\tcookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n\t\t\t...opt,\n\t\t\tpath: \"/\",\n\t\t\tsecure: true,\n\t\t\tdomain: undefined,\n\t\t});\n\t} else {\n\t\tcookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n\t}\n\theader.append(\"Set-Cookie\", cookie);\n};\n\nexport const getSignedCookie = async (\n\theader: Headers,\n\tsecret: string,\n\tkey: string,\n\tprefix?: CookiePrefixOptions,\n) => {\n\tconst cookie = header.get(\"cookie\");\n\tif (!cookie) {\n\t\treturn undefined;\n\t}\n\tlet finalKey = key;\n\tif (prefix) {\n\t\tif (prefix === \"secure\") {\n\t\t\tfinalKey = \"__Secure-\" + key;\n\t\t} else if (prefix === \"host\") {\n\t\t\tfinalKey = \"__Host-\" + key;\n\t\t}\n\t}\n\tconst obj = await parseSigned(cookie, secret, finalKey);\n\treturn obj[finalKey];\n};\n","import { createRouter as createRou3Router, addRoute, findRoute, findAllRoutes } from \"rou3\";\nimport { getBody, shouldSerialize, statusCode } from \"./utils\";\nimport { APIError } from \"./error\";\nimport type { Endpoint } from \"./types\";\n\ninterface RouterConfig {\n\t/**\n\t * Throw error if error occurred other than APIError\n\t */\n\tthrowError?: boolean;\n\t/**\n\t * Handle error\n\t */\n\tonError?: (e: unknown) => void | Promise<void> | Response | Promise<Response>;\n\t/**\n\t * Base path for the router\n\t */\n\tbasePath?: string;\n\t/**\n\t * Middlewares for the router\n\t */\n\trouterMiddleware?: {\n\t\tpath: string;\n\t\tmiddleware: Endpoint;\n\t}[];\n\textraContext?: Record<string, any>;\n\tonResponse?: (res: Response) => any | Promise<any>;\n\tonRequest?: (req: Request) => any | Promise<any>;\n}\n\nexport const createRouter = <E extends Record<string, Endpoint>, Config extends RouterConfig>(\n\tendpoints: E,\n\tconfig?: Config,\n) => {\n\tconst _endpoints = Object.values(endpoints);\n\tconst router = createRou3Router();\n\tfor (const endpoint of _endpoints) {\n\t\tif (Array.isArray(endpoint.options?.method)) {\n\t\t\tfor (const method of endpoint.options.method) {\n\t\t\t\taddRoute(router, method, endpoint.path, endpoint);\n\t\t\t}\n\t\t} else {\n\t\t\taddRoute(router, endpoint.options.method, endpoint.path, endpoint);\n\t\t}\n\t}\n\n\tconst middlewareRouter = createRou3Router();\n\tfor (const route of config?.routerMiddleware || []) {\n\t\taddRoute(middlewareRouter, \"*\", route.path, route.middleware);\n\t}\n\n\tconst handler = async (request: Request) => {\n\t\tconst url = new URL(request.url);\n\t\tlet path = url.pathname;\n\t\tif (config?.basePath) {\n\t\t\tpath = path.split(config.basePath)[1];\n\t\t}\n\t\tif (!path?.length) {\n\t\t\tconfig?.onError?.(new APIError(\"NOT_FOUND\"));\n\t\t\tconsole.warn(\n\t\t\t\t`[better-call]: Make sure the URL has the basePath (${config?.basePath}).`,\n\t\t\t);\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 404,\n\t\t\t\tstatusText: \"Not Found\",\n\t\t\t});\n\t\t}\n\t\tconst method = request.method;\n\t\tconst route = findRoute(router, method, path);\n\t\tconst handler = route?.data as Endpoint;\n\t\tconst body = await getBody(request);\n\t\tconst headers = request.headers;\n\t\tconst query = Object.fromEntries(url.searchParams);\n\t\tconst routerMiddleware = findAllRoutes(middlewareRouter, \"*\", path);\n\t\t//handler 404\n\t\tif (!handler) {\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 404,\n\t\t\t\tstatusText: \"Not Found\",\n\t\t\t});\n\t\t}\n\t\ttry {\n\t\t\tlet middlewareContext: Record<string, any> = {};\n\t\t\tif (routerMiddleware?.length) {\n\t\t\t\tfor (const route of routerMiddleware) {\n\t\t\t\t\tconst middleware = route.data as Endpoint;\n\t\t\t\t\tconst res = await middleware({\n\t\t\t\t\t\tpath: path,\n\t\t\t\t\t\tmethod: method as \"GET\",\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tparams: route?.params as any,\n\t\t\t\t\t\trequest: request,\n\t\t\t\t\t\tbody: body,\n\t\t\t\t\t\tquery,\n\t\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\t...config?.extraContext,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tif (res instanceof Response) {\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\tif (res?._flag === \"json\") {\n\t\t\t\t\t\treturn new Response(JSON.stringify(res), {\n\t\t\t\t\t\t\theaders: res.headers,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tmiddlewareContext = {\n\t\t\t\t\t\t\t...res,\n\t\t\t\t\t\t\t...middlewareContext,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst handlerRes = await handler({\n\t\t\t\tpath: path,\n\t\t\t\tmethod: method as \"GET\",\n\t\t\t\theaders,\n\t\t\t\tparams: route?.params as any,\n\t\t\t\trequest: request,\n\t\t\t\tbody: body,\n\t\t\t\tquery,\n\t\t\t\t_flag: \"router\",\n\t\t\t\tcontext: {\n\t\t\t\t\t...middlewareContext,\n\t\t\t\t\t...config?.extraContext,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (handlerRes instanceof Response) {\n\t\t\t\treturn handlerRes;\n\t\t\t}\n\t\t\tconst resBody = shouldSerialize(handlerRes) ? JSON.stringify(handlerRes) : handlerRes;\n\t\t\treturn new Response(resBody as any, {\n\t\t\t\theaders: handler.headers,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tif (config?.onError) {\n\t\t\t\tconst onErrorRes = await config.onError(e);\n\t\t\t\tif (onErrorRes instanceof Response) {\n\t\t\t\t\treturn onErrorRes;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e instanceof APIError) {\n\t\t\t\treturn new Response(e.body ? JSON.stringify(e.body) : null, {\n\t\t\t\t\tstatus: statusCode[e.status],\n\t\t\t\t\tstatusText: e.status,\n\t\t\t\t\theaders: handler.headers,\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (config?.throwError) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 500,\n\t\t\t\tstatusText: \"Internal Server Error\",\n\t\t\t});\n\t\t}\n\t};\n\treturn {\n\t\thandler: async (request: Request) => {\n\t\t\tconst onReq = await config?.onRequest?.(request);\n\t\t\tif (onReq instanceof Response) {\n\t\t\t\treturn onReq;\n\t\t\t}\n\t\t\tconst req = onReq instanceof Request ? onReq : request;\n\t\t\tconst res = await handler(req);\n\t\t\tconst onRes = await config?.onResponse?.(res);\n\t\t\tif (onRes instanceof Response) {\n\t\t\t\treturn onRes;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\tendpoints,\n\t};\n};\n\nexport type Router = ReturnType<typeof createRouter>;\n","export async function getBody(request: Request) {\n\tconst contentType = request.headers.get(\"content-type\") || \"\";\n\n\tif (!request.body) {\n\t\treturn undefined;\n\t}\n\n\tif (contentType.includes(\"application/json\")) {\n\t\treturn await request.json();\n\t}\n\n\tif (contentType.includes(\"application/x-www-form-urlencoded\")) {\n\t\tconst formData = await request.formData();\n\t\tconst result: Record<string, string> = {};\n\t\tformData.forEach((value, key) => {\n\t\t\tresult[key] = value.toString();\n\t\t});\n\t\treturn result;\n\t}\n\n\tif (contentType.includes(\"multipart/form-data\")) {\n\t\tconst formData = await request.formData();\n\t\tconst result: Record<string, any> = {};\n\t\tformData.forEach((value, key) => {\n\t\t\tresult[key] = value;\n\t\t});\n\t\treturn result;\n\t}\n\n\tif (contentType.includes(\"text/plain\")) {\n\t\treturn await request.text();\n\t}\n\n\tif (contentType.includes(\"application/octet-stream\")) {\n\t\treturn await request.arrayBuffer();\n\t}\n\n\tif (\n\t\tcontentType.includes(\"application/pdf\") ||\n\t\tcontentType.includes(\"image/\") ||\n\t\tcontentType.includes(\"video/\")\n\t) {\n\t\tconst blob = await request.blob();\n\t\treturn blob;\n\t}\n\n\tif (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n\t\treturn request.body;\n\t}\n\n\treturn await request.text();\n}\n\nexport function shouldSerialize(body: any) {\n\treturn (\n\t\ttypeof body === \"object\" &&\n\t\tbody !== null &&\n\t\t!(body instanceof Blob) &&\n\t\t!(body instanceof FormData)\n\t);\n}\n\nexport const statusCode = {\n\tOK: 200,\n\tCREATED: 201,\n\tACCEPTED: 202,\n\tNO_CONTENT: 204,\n\tMULTIPLE_CHOICES: 300,\n\tMOVED_PERMANENTLY: 301,\n\tFOUND: 302,\n\tSEE_OTHER: 303,\n\tNOT_MODIFIED: 304,\n\tTEMPORARY_REDIRECT: 307,\n\tBAD_REQUEST: 400,\n\tUNAUTHORIZED: 401,\n\tPAYMENT_REQUIRED: 402,\n\tFORBIDDEN: 403,\n\tNOT_FOUND: 404,\n\tMETHOD_NOT_ALLOWED: 405,\n\tNOT_ACCEPTABLE: 406,\n\tPROXY_AUTHENTICATION_REQUIRED: 407,\n\tREQUEST_TIMEOUT: 408,\n\tCONFLICT: 409,\n\tGONE: 410,\n\tLENGTH_REQUIRED: 411,\n\tPRECONDITION_FAILED: 412,\n\tPAYLOAD_TOO_LARGE: 413,\n\tURI_TOO_LONG: 414,\n\tUNSUPPORTED_MEDIA_TYPE: 415,\n\tRANGE_NOT_SATISFIABLE: 416,\n\tEXPECTATION_FAILED: 417,\n\t\"I'M_A_TEAPOT\": 418,\n\tMISDIRECTED_REQUEST: 421,\n\tUNPROCESSABLE_ENTITY: 422,\n\tLOCKED: 423,\n\tFAILED_DEPENDENCY: 424,\n\tTOO_EARLY: 425,\n\tUPGRADE_REQUIRED: 426,\n\tPRECONDITION_REQUIRED: 428,\n\tTOO_MANY_REQUESTS: 429,\n\tREQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n\tUNAVAILABLE_FOR_LEGAL_REASONS: 451,\n\tINTERNAL_SERVER_ERROR: 500,\n\tNOT_IMPLEMENTED: 501,\n\tBAD_GATEWAY: 502,\n\tSERVICE_UNAVAILABLE: 503,\n\tGATEWAY_TIMEOUT: 504,\n\tHTTP_VERSION_NOT_SUPPORTED: 505,\n\tVARIANT_ALSO_NEGOTIATES: 506,\n\tINSUFFICIENT_STORAGE: 507,\n\tLOOP_DETECTED: 508,\n\tNOT_EXTENDED: 510,\n\tNETWORK_AUTHENTICATION_REQUIRED: 511,\n};\n","import type {\n\tContextTools,\n\tEndpoint,\n\tEndpointOptions,\n\tEndpointResponse,\n\tHandler,\n\tInferBody,\n\tInferHeaders,\n\tInferRequest,\n\tInferUse,\n\tPrettify,\n} from \"./types\";\nimport { createEndpoint } from \"./endpoint\";\n\nexport type MiddlewareHandler<\n\tOpts extends EndpointOptions,\n\tR extends EndpointResponse,\n\tExtra extends Record<string, any> = {},\n> = (\n\tctx: Prettify<\n\t\tInferBody<Opts> &\n\t\t\tInferRequest<Opts> &\n\t\t\tInferHeaders<Opts> & {\n\t\t\t\tparams?: Record<string, string>;\n\t\t\t\tquery?: Record<string, string>;\n\t\t\t} & ContextTools\n\t> &\n\t\tExtra,\n) => Promise<R>;\n\nexport function createMiddleware<Opts extends EndpointOptions, R extends EndpointResponse>(\n\toptionsOrHandler: MiddlewareHandler<Opts, R>,\n): Endpoint<Handler<string, Opts, R>, Opts>;\nexport function createMiddleware<\n\tOpts extends Omit<EndpointOptions, \"method\">,\n\tR extends EndpointResponse,\n>(\n\toptionsOrHandler: Opts,\n\thandler: MiddlewareHandler<\n\t\tOpts & {\n\t\t\tmethod: \"*\";\n\t\t},\n\t\tR\n\t>,\n): Endpoint<\n\tHandler<\n\t\tstring,\n\t\tOpts & {\n\t\t\tmethod: \"*\";\n\t\t},\n\t\tR\n\t>,\n\tOpts & {\n\t\tmethod: \"*\";\n\t}\n>;\nexport function createMiddleware(optionsOrHandler: any, handler?: any) {\n\tif (typeof optionsOrHandler === \"function\") {\n\t\treturn createEndpoint(\n\t\t\t\"*\",\n\t\t\t{\n\t\t\t\tmethod: \"*\",\n\t\t\t},\n\t\t\toptionsOrHandler,\n\t\t);\n\t}\n\tif (!handler) {\n\t\tthrow new Error(\"Middleware handler is required\");\n\t}\n\tconst endpoint = createEndpoint(\n\t\t\"*\",\n\t\t{\n\t\t\t...optionsOrHandler,\n\t\t\tmethod: \"*\",\n\t\t},\n\t\thandler,\n\t);\n\treturn endpoint as any;\n}\n\nexport const createMiddlewareCreator = <\n\tE extends {\n\t\tuse?: Endpoint[];\n\t},\n>(\n\topts?: E,\n) => {\n\ttype H<Opts extends EndpointOptions, R extends EndpointResponse> = (\n\t\tctx: Prettify<\n\t\t\tInferBody<Opts> &\n\t\t\t\tInferUse<E[\"use\"]> &\n\t\t\t\tInferRequest<Opts> &\n\t\t\t\tInferHeaders<Opts> & {\n\t\t\t\t\tparams?: Record<string, string>;\n\t\t\t\t\tquery?: Record<string, string>;\n\t\t\t\t} & ContextTools\n\t\t>,\n\t) => Promise<R>;\n\tfunction fn<Opts extends EndpointOptions, R extends EndpointResponse>(\n\t\toptionsOrHandler: H<Opts, R>,\n\t): Endpoint<Handler<string, Opts, R>, Opts>;\n\tfunction fn<Opts extends Omit<EndpointOptions, \"method\">, R extends EndpointResponse>(\n\t\toptionsOrHandler: Opts,\n\t\thandler: H<\n\t\t\tOpts & {\n\t\t\t\tmethod: \"*\";\n\t\t\t},\n\t\t\tR\n\t\t>,\n\t): Endpoint<\n\t\tHandler<\n\t\t\tstring,\n\t\t\tOpts & {\n\t\t\t\tmethod: \"*\";\n\t\t\t},\n\t\t\tR\n\t\t>,\n\t\tOpts & {\n\t\t\tmethod: \"*\";\n\t\t}\n\t>;\n\tfunction fn(optionsOrHandler: any, handler?: any) {\n\t\tif (typeof optionsOrHandler === \"function\") {\n\t\t\treturn createEndpoint(\n\t\t\t\t\"*\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"*\",\n\t\t\t\t},\n\t\t\t\toptionsOrHandler,\n\t\t\t);\n\t\t}\n\t\tif (!handler) {\n\t\t\tthrow new Error(\"Middleware handler is required\");\n\t\t}\n\t\tconst endpoint = createEndpoint(\n\t\t\t\"*\",\n\t\t\t{\n\t\t\t\t...optionsOrHandler,\n\t\t\t\tmethod: \"*\",\n\t\t\t},\n\t\t\thandler,\n\t\t);\n\t\treturn endpoint as any;\n\t}\n\treturn fn;\n};\n\nexport type Middleware<\n\tOpts extends EndpointOptions = EndpointOptions,\n\tR extends EndpointResponse = EndpointResponse,\n> = (\n\topts: Opts,\n\thandler: (ctx: {\n\t\tbody?: InferBody<Opts>;\n\t\tparams?: Record<string, string>;\n\t\tquery?: Record<string, string>;\n\t}) => Promise<R>,\n) => Endpoint;\n","import { z, type ZodOptional, type ZodSchema } from \"zod\";\nimport type { json, UnionToIntersection } from \"./helper\";\nimport type { CookieOptions, CookiePrefixOptions } from \"./cookie\";\nimport type { APIError } from \"./error\";\n\nexport interface EndpointOptions {\n\t/**\n\t * Request Method\n\t */\n\tmethod: Method | Method[];\n\t/**\n\t * Body Schema\n\t */\n\tbody?: ZodSchema;\n\t/**\n\t * Query Schema\n\t */\n\tquery?: ZodSchema;\n\t/**\n\t * If true headers will be required to be passed in the context\n\t */\n\trequireHeaders?: boolean;\n\t/**\n\t * If true request object will be required\n\t */\n\trequireRequest?: boolean;\n\t/**\n\t * List of endpoints that will be called before this endpoint\n\t */\n\tuse?: Endpoint[];\n\t/**\n\t * Endpoint metadata\n\t */\n\tmetadata?: Record<string, any>;\n}\n\nexport type Endpoint<\n\tHandler extends (ctx: any) => Promise<any> = (ctx: any) => Promise<any>,\n\tOption extends EndpointOptions = EndpointOptions,\n> = {\n\tpath: string;\n\toptions: Option;\n\theaders?: Headers;\n} & Handler;\n\nexport type InferParamPath<Path> = Path extends `${infer _Start}:${infer Param}/${infer Rest}`\n\t? { [K in Param | keyof InferParamPath<Rest>]: string }\n\t: Path extends `${infer _Start}:${infer Param}`\n\t\t? { [K in Param]: string }\n\t\t: Path extends `${infer _Start}/${infer Rest}`\n\t\t\t? InferParamPath<Rest>\n\t\t\t: undefined;\n\nexport type InferParamWildCard<Path> = Path extends\n\t| `${infer _Start}/*:${infer Param}/${infer Rest}`\n\t| `${infer _Start}/**:${infer Param}/${infer Rest}`\n\t? { [K in Param | keyof InferParamPath<Rest>]: string }\n\t: Path extends `${infer _Start}/*`\n\t\t? { [K in \"_\"]: string }\n\t\t: Path extends `${infer _Start}/${infer Rest}`\n\t\t\t? InferParamPath<Rest>\n\t\t\t: undefined;\n\nexport type Prettify<T> = {\n\t[key in keyof T]: T[key];\n} & {};\n\nexport type ContextTools = {\n\t/**\n\t * the current path\n\t */\n\tpath: string;\n\t/**\n\t * Set header\n\t *\n\t * If it's called outside of a request it will just be ignored.\n\t */\n\tsetHeader: (key: string, value: string) => void;\n\t/**\n\t * cookie setter.\n\t *\n\t * If it's called outside of a request it will just be ignored.\n\t */\n\tsetCookie: (key: string, value: string, options?: CookieOptions) => void;\n\t/**\n\t * Get cookie value\n\t *\n\t * If it's called outside of a request it will just be ignored.\n\t */\n\tgetCookie: (key: string, prefix?: CookiePrefixOptions) => string | undefined;\n\t/**\n\t * Set signed cookie\n\t */\n\tsetSignedCookie: (\n\t\tkey: string,\n\t\tvalue: string,\n\t\tsecret: string | BufferSource,\n\t\toptions?: CookieOptions,\n\t) => Promise<void>;\n\t/**\n\t * Get signed cookie value\n\t */\n\n\tgetSignedCookie: (\n\t\tkey: string,\n\t\tsecret: string,\n\t\tprefix?: CookiePrefixOptions,\n\t) => Promise<string | undefined>;\n\t/**\n\t * Redirect to url\n\t */\n\tredirect: (url: string) => APIError;\n\t/**\n\t * json response helper\n\t */\n\tjson: typeof json;\n\t/**\n\t * internal flags\n\t */\n\t_flag?: string;\n\t/**\n\t * response header\n\t */\n\tresponseHeader: Headers;\n};\n\nexport type Context<Path extends string, Opts extends EndpointOptions> = InferBody<Opts> &\n\tInferParam<Path> &\n\tInferMethod<Opts[\"method\"]> &\n\tInferHeaders<Opts> &\n\tInferRequest<Opts> &\n\tInferQuery<Opts[\"query\"]>;\n\nexport type InferUse<Opts extends EndpointOptions[\"use\"]> = Opts extends Endpoint[]\n\t? {\n\t\t\tcontext: UnionToIntersection<Awaited<ReturnType<Opts[number]>>>;\n\t\t}\n\t: {};\n\nexport type InferUseOptions<Opts extends EndpointOptions> = Opts[\"use\"] extends Array<infer U>\n\t? UnionToIntersection<\n\t\t\tU extends Endpoint\n\t\t\t\t? U[\"options\"]\n\t\t\t\t: {\n\t\t\t\t\t\tbody?: {};\n\t\t\t\t\t\trequireRequest?: boolean;\n\t\t\t\t\t\trequireHeaders?: boolean;\n\t\t\t\t\t}\n\t\t>\n\t: {\n\t\t\tbody?: {};\n\t\t\trequireRequest?: boolean;\n\t\t\trequireHeaders?: boolean;\n\t\t};\n\nexport type InferMethod<M extends Method | Method[]> = M extends Array<Method>\n\t? {\n\t\t\tmethod: M[number];\n\t\t}\n\t: {\n\t\t\tmethod?: M;\n\t\t};\n\nexport type InferHeaders<\n\tOpt extends EndpointOptions,\n\tHeaderReq = Opt[\"requireHeaders\"],\n> = HeaderReq extends true\n\t? {\n\t\t\theaders: Headers;\n\t\t}\n\t: InferUseOptions<Opt>[\"requireHeaders\"] extends true\n\t\t? {\n\t\t\t\theaders: Headers;\n\t\t\t}\n\t\t: {\n\t\t\t\theaders?: Headers;\n\t\t\t};\n\nexport type InferRequest<\n\tOpt extends EndpointOptions,\n\tRequestReq = Opt[\"requireRequest\"],\n> = RequestReq extends true\n\t? {\n\t\t\trequest: Request;\n\t\t}\n\t: InferUseOptions<Opt>[\"requireRequest\"] extends true\n\t\t? {\n\t\t\t\trequest: Request;\n\t\t\t}\n\t\t: {\n\t\t\t\trequest?: Request;\n\t\t\t};\n\nexport type InferQuery<Query> = Query extends ZodSchema\n\t? Query extends ZodOptional<any>\n\t\t? {\n\t\t\t\tquery?: z.infer<Query>;\n\t\t\t}\n\t\t: {\n\t\t\t\tquery: z.infer<Query>;\n\t\t\t}\n\t: {\n\t\t\tquery?: undefined;\n\t\t};\n\nexport type InferParam<\n\tPath extends string,\n\tParamPath extends InferParamPath<Path> = InferParamPath<Path>,\n\tWildCard extends InferParamWildCard<Path> = InferParamWildCard<Path>,\n> = ParamPath extends undefined\n\t? WildCard extends undefined\n\t\t? {\n\t\t\t\tparams?: Record<string, string>;\n\t\t\t}\n\t\t: {\n\t\t\t\tparams: WildCard;\n\t\t\t}\n\t: {\n\t\t\tparams: Prettify<ParamPath & (WildCard extends undefined ? {} : WildCard)>;\n\t\t};\n\nexport type EndpointBody =\n\t| Record<string, any>\n\t| string\n\t| boolean\n\t| number\n\t| void\n\t| undefined\n\t| null\n\t| unknown;\n\nexport type EndpointResponse =\n\t| {\n\t\t\tresponse: {\n\t\t\t\tstatus?: number;\n\t\t\t\tstatusText?: string;\n\t\t\t\theaders?: Headers;\n\t\t\t\tbody: any;\n\t\t\t};\n\t\t\tbody: EndpointBody;\n\t\t\t_flag: \"json\";\n\t  }\n\t| EndpointBody;\n\nexport type Handler<\n\tPath extends string,\n\tOpts extends EndpointOptions,\n\tR extends EndpointResponse,\n> = (\n\tctx: Prettify<Context<Path, Opts> & InferUse<Opts[\"use\"]> & Omit<ContextTools, \"_flag\">>,\n) => Promise<R>;\n\nexport type Method = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\" | \"*\";\n\nexport type InferBody<\n\tOpts extends EndpointOptions,\n\tBody extends ZodSchema | undefined = Opts[\"body\"] &\n\t\t(undefined extends InferUseOptions<Opts>[\"body\"] ? {} : InferUseOptions<Opts>[\"body\"]),\n> = Body extends ZodSchema\n\t? Body extends ZodOptional<any>\n\t\t? {\n\t\t\t\tbody?: Prettify<z.infer<Body>>;\n\t\t\t}\n\t\t: {\n\t\t\t\tbody: Prettify<z.infer<Body>>;\n\t\t\t}\n\t: {\n\t\t\tbody?: undefined;\n\t\t};\n","import { IncomingMessage, ServerResponse } from \"node:http\";\n\nimport { getRequest, setResponse } from \"./request.js\";\nimport type { Router } from \"../router.js\";\n\nexport function toNodeHandler(handler: Router[\"handler\"]) {\n\treturn async (req: IncomingMessage, res: ServerResponse) => {\n\t\tconst protocol = (req.connection as any)?.encrypted ? \"https\" : \"http\";\n\t\tconst base = `${protocol}://${req.headers[\":authority\"] || req.headers.host}`;\n\t\tconst response = await handler(getRequest({ base, request: req }));\n\t\tsetResponse(res, response);\n\t};\n}\n\nexport { getRequest, setResponse };\n","import { IncomingMessage, ServerResponse } from \"node:http\";\nimport * as set_cookie_parser from \"set-cookie-parser\";\n\nfunction get_raw_body(req: IncomingMessage, body_size_limit?: number) {\n\tconst h = req.headers;\n\n\tif (!h[\"content-type\"]) return null;\n\n\tconst content_length = Number(h[\"content-length\"]);\n\n\t// check if no request body\n\tif (\n\t\t(req.httpVersionMajor === 1 && isNaN(content_length) && h[\"transfer-encoding\"] == null) ||\n\t\tcontent_length === 0\n\t) {\n\t\treturn null;\n\t}\n\n\tlet length = content_length;\n\n\tif (body_size_limit) {\n\t\tif (!length) {\n\t\t\tlength = body_size_limit;\n\t\t} else if (length > body_size_limit) {\n\t\t\tthrow Error(\n\t\t\t\t`Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`,\n\t\t\t);\n\t\t}\n\t}\n\n\tif (req.destroyed) {\n\t\tconst readable = new ReadableStream();\n\t\treadable.cancel();\n\t\treturn readable;\n\t}\n\n\tlet size = 0;\n\tlet cancelled = false;\n\n\treturn new ReadableStream({\n\t\tstart(controller) {\n\t\t\treq.on(\"error\", (error) => {\n\t\t\t\tcancelled = true;\n\t\t\t\tcontroller.error(error);\n\t\t\t});\n\n\t\t\treq.on(\"end\", () => {\n\t\t\t\tif (cancelled) return;\n\t\t\t\tcontroller.close();\n\t\t\t});\n\n\t\t\treq.on(\"data\", (chunk) => {\n\t\t\t\tif (cancelled) return;\n\n\t\t\t\tsize += chunk.length;\n\n\t\t\t\tif (size > length) {\n\t\t\t\t\tcancelled = true;\n\n\t\t\t\t\tcontroller.error(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`request body size exceeded ${\n\t\t\t\t\t\t\t\tcontent_length ? \"'content-length'\" : \"BODY_SIZE_LIMIT\"\n\t\t\t\t\t\t\t} of ${length}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcontroller.enqueue(chunk);\n\n\t\t\t\tif (controller.desiredSize === null || controller.desiredSize <= 0) {\n\t\t\t\t\treq.pause();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tpull() {\n\t\t\treq.resume();\n\t\t},\n\n\t\tcancel(reason) {\n\t\t\tcancelled = true;\n\t\t\treq.destroy(reason);\n\t\t},\n\t});\n}\n\nexport function getRequest({\n\trequest,\n\tbase,\n\tbodySizeLimit,\n}: {\n\tbase: string;\n\tbodySizeLimit?: number;\n\trequest: IncomingMessage;\n}) {\n\treturn new Request(base + request.url, {\n\t\t// @ts-expect-error\n\t\tduplex: \"half\",\n\t\tmethod: request.method,\n\t\tbody: get_raw_body(request, bodySizeLimit),\n\t\theaders: request.headers as Record<string, string>,\n\t});\n}\n\nexport async function setResponse(res: ServerResponse, response: Response) {\n\tfor (const [key, value] of response.headers as any) {\n\t\ttry {\n\t\t\tres.setHeader(\n\t\t\t\tkey,\n\t\t\t\tkey === \"set-cookie\"\n\t\t\t\t\t? set_cookie_parser.splitCookiesString(response.headers.get(key) as string)\n\t\t\t\t\t: value,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tres.getHeaderNames().forEach((name) => res.removeHeader(name));\n\t\t\tres.writeHead(500).end(String(error));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tres.writeHead(response.status);\n\n\tif (!response.body) {\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tif (response.body.locked) {\n\t\tres.end(\n\t\t\t\"Fatal error: Response body is locked. \" +\n\t\t\t\t\"This can happen when the response was already read (for example through 'response.json()' or 'response.text()').\",\n\t\t);\n\t\treturn;\n\t}\n\n\tconst reader = response.body.getReader();\n\n\tif (res.destroyed) {\n\t\treader.cancel();\n\t\treturn;\n\t}\n\n\tconst cancel = (error?: Error) => {\n\t\tres.off(\"close\", cancel);\n\t\tres.off(\"error\", cancel);\n\n\t\t// If the reader has already been interrupted with an error earlier,\n\t\t// then it will appear here, it is useless, but it needs to be catch.\n\t\treader.cancel(error).catch(() => {});\n\t\tif (error) res.destroy(error);\n\t};\n\n\tres.on(\"close\", cancel);\n\tres.on(\"error\", cancel);\n\n\tnext();\n\tasync function next() {\n\t\ttry {\n\t\t\tfor (;;) {\n\t\t\t\tconst { done, value } = await reader.read();\n\n\t\t\t\tif (done) break;\n\n\t\t\t\tif (!res.write(value)) {\n\t\t\t\t\tres.once(\"drain\", next);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.end();\n\t\t} catch (error) {\n\t\t\tcancel(error instanceof Error ? error : new Error(String(error)));\n\t\t}\n\t}\n}\n"],"mappings":"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","names":["options","res","createRou3Router","handler","route","import_zod","import_node_http"]}